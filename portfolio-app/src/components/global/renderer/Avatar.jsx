/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/dot-notation */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 .\Avatar.glb 
*/
import React, { useRef, useMemo, useEffect, useState } from 'react'
import { useGraph, useThree, useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import * as THREE from 'three'

export function Avatar(props) {
  const orbit = useRef()
  const group = useRef()
  const { scene, animations } = useGLTF('/models/Avatar.glb')
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
  const { actions } = useAnimations(animations, group)
  const { camera, size } = useThree()

  const [isDragging, setIsDragging] = useState(false)
  const [previousPosition, setPreviousPosition] = useState({ x: 0, y: 0 })
  const [rotationVelocity, setRotationVelocity] = useState({ x: 0, y: 0 })

  useEffect(() => {
    actions['LookingArround'].play()
  }, [actions])

  const handlePointerDown = (event) => {
    setIsDragging(true)
    setPreviousPosition({
      x: event.clientX || event.touches[0].clientX,
      y: event.clientY || event.touches[0].clientY
    })
    setRotationVelocity({ x: 0, y: 0 })
  }

  const handlePointerMove = (event) => {
    if (!isDragging) return

    const clientX = event.clientX || event.touches[0].clientX
    const clientY = event.clientY || event.touches[0].clientY

    const deltaX = clientX - previousPosition.x
    const deltaY = clientY - previousPosition.y

    // Calculate rotation based on screen size for consistent feel across devices
    const rotationSpeed = 4 * Math.PI / Math.max(size.width, size.height)

    setRotationVelocity({
      x: deltaY * rotationSpeed,
      y: deltaX * rotationSpeed
    })

    setPreviousPosition({ x: clientX, y: clientY })
  }

  const handlePointerUp = () => {
    setIsDragging(false)
  }

  useFrame((state, delta) => {
    if (orbit.current) {
      // Apply rotation
      orbit.current.rotation.x += rotationVelocity.x
      orbit.current.rotation.y += rotationVelocity.y

      // Clamp vertical rotation to avoid flipping
      orbit.current.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, orbit.current.rotation.x))

      // Apply damping to slow down rotation when not dragging
      if (!isDragging) {
        const damping = 0.95
        setRotationVelocity(prev => ({
          x: prev.x * damping,
          y: prev.y * damping
        }))
      }
    }
  })

  useEffect(() => {
    const canvas = document.querySelector('canvas')
    if (canvas) {
      canvas.addEventListener('pointerdown', handlePointerDown)
      canvas.addEventListener('pointermove', handlePointerMove)
      canvas.addEventListener('pointerup', handlePointerUp)
      canvas.addEventListener('pointerleave', handlePointerUp)

      return () => {
        canvas.removeEventListener('pointerdown', handlePointerDown)
        canvas.removeEventListener('pointermove', handlePointerMove)
        canvas.removeEventListener('pointerup', handlePointerUp)
        canvas.removeEventListener('pointerleave', handlePointerUp)
      }
    }
  }, [size, handlePointerDown, handlePointerMove, handlePointerUp])

  return (
    <group ref={group} {...props} dispose={null} position={[0, -1, 0]}>
      <group name="Scene">
        <group ref={orbit} name="Orbit" position={[-0.065, 1.323, -0.062]} rotation={[0, 0.001, 0.02]} scale={0.683}>
          <mesh name="Planet" geometry={nodes.Planet.geometry} material={nodes.Planet.material} position={[0.947, 0.535, -1.034]} scale={0.192} />
           <mesh name="Planet-1" geometry={nodes.Planet.geometry} material={nodes.Planet.material} position={[0.947, 0.535, 1.034]} scale={0.192} />
           <mesh name="Planet-2" geometry={nodes.Planet.geometry} material={nodes.Planet.material} position={[-1.034, 0.535, 0.947]} scale={0.192} />
        </group>
        <group name="Avatar">
          <primitive object={nodes.Hips} />
          <group name="body">
            <skinnedMesh name="avaturn_shoes_0" geometry={nodes.avaturn_shoes_0.geometry} material={materials.avaturn_shoes_0_material} skeleton={nodes.avaturn_shoes_0.skeleton} />
            <skinnedMesh name="avaturn_shoes_0_1" geometry={nodes.avaturn_shoes_0_1.geometry} material={materials.avaturn_body_material} skeleton={nodes.avaturn_shoes_0_1.skeleton} />
            <skinnedMesh name="avaturn_shoes_0_2" geometry={nodes.avaturn_shoes_0_2.geometry} material={materials.avaturn_glasses_0_material} skeleton={nodes.avaturn_shoes_0_2.skeleton} />
            <skinnedMesh name="avaturn_shoes_0_3" geometry={nodes.avaturn_shoes_0_3.geometry} material={materials.avaturn_glasses_1_material} skeleton={nodes.avaturn_shoes_0_3.skeleton} />
            <skinnedMesh name="avaturn_shoes_0_4" geometry={nodes.avaturn_shoes_0_4.geometry} material={materials.avaturn_look_0_material} skeleton={nodes.avaturn_shoes_0_4.skeleton} />
          </group>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/models/Avatar.glb')