// @ts-nocheck
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/dot-notation */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 .\Avatar.glb 
*/
import React, { useRef, useMemo, useEffect, useState, useCallback } from 'react'
import { useGraph, useThree, useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import * as THREE from 'three'

export function Avatar(props) {
  const orbit = useRef()
  const group = useRef()
  const { scene, animations } = useGLTF('/models/Avatar.glb')
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)
  const { actions } = useAnimations(animations, group)
  const { size } = useThree()

  const [isDragging, setIsDragging] = useState(false)
  const [previousPosition, setPreviousPosition] = useState({ x: 0, y: 0 })
  const [rotationVelocity, setRotationVelocity] = useState({ x: 0, y: 0 })
  const [isSwipeAnimationPlaying, setIsSwipeAnimationPlaying] = useState(false)

  const startSwipeAnimation = useCallback(() => {
    actions['LookingArround'].stop()
    actions['gesture_1'].reset().play()
    setIsSwipeAnimationPlaying(true)
  }, [actions])

  const stopSwipeAnimation = useCallback(() => {
    actions['gesture_1'].fadeOut(0.5)
    actions['LookingArround'].reset().fadeIn(0.5).play()
    setIsSwipeAnimationPlaying(false)
  }, [actions])

  useEffect(() => {
    actions['LookingArround'].play()
  }, [actions])

  useFrame(() => {
    if (orbit.current) {
      // Apply rotation
      orbit.current.rotation.x += rotationVelocity.x
      orbit.current.rotation.y += rotationVelocity.y

      // Allow full rotation
      orbit.current.rotation.x = (orbit.current.rotation.x + Math.PI) % (2 * Math.PI) - Math.PI
      orbit.current.rotation.y = orbit.current.rotation.y % (2 * Math.PI)

      // Apply damping to slow down rotation when not dragging
      if (!isDragging) {
        const damping = 0.95
        const newVelocityX = rotationVelocity.x * damping
        const newVelocityY = rotationVelocity.y * damping

        setRotationVelocity({ x: newVelocityX, y: newVelocityY })

        // Stop the swipe animation when the rotation has slowed significantly
        if (Math.abs(newVelocityX) < 0.001 && Math.abs(newVelocityY) < 0.001 && isSwipeAnimationPlaying) {
          stopSwipeAnimation()
        }
      }
    }
  })

  const handlePointerDown = useCallback((event) => {
    setIsDragging(true)
    setPreviousPosition({
      x: event.clientX || event.touches[0].clientX,
      y: event.clientY || event.touches[0].clientY
    })
  }, [])

  const handlePointerMove = useCallback((event) => {
    if (!isDragging) return

    const clientX = event.clientX || event.touches[0].clientX
    const clientY = event.clientY || event.touches[0].clientY

    const deltaX = clientX - previousPosition.x
    const deltaY = clientY - previousPosition.y

    // Calculate rotation based on screen size for consistent feel across devices
    const rotationSpeed = 4 * Math.PI / Math.max(size.width, size.height)

    setRotationVelocity({
      x: deltaY * rotationSpeed,
      y: deltaX * rotationSpeed
    })

    setPreviousPosition({ x: clientX, y: clientY })

    if (!isSwipeAnimationPlaying) {
      startSwipeAnimation()
    }
  }, [isDragging, previousPosition, size, isSwipeAnimationPlaying, startSwipeAnimation])

  const handlePointerUp = useCallback(() => {
    setIsDragging(false)
  }, [])

  useEffect(() => {
    const canvas = document.querySelector('canvas')

    if (canvas) {
      canvas.addEventListener('pointerdown', handlePointerDown)
      canvas.addEventListener('pointermove', handlePointerMove)
      canvas.addEventListener('pointerup', handlePointerUp)
      canvas.addEventListener('pointerleave', handlePointerUp)

      return () => {
        canvas.removeEventListener('pointerdown', handlePointerDown)
        canvas.removeEventListener('pointermove', handlePointerMove)
        canvas.removeEventListener('pointerup', handlePointerUp)
        canvas.removeEventListener('pointerleave', handlePointerUp)
      }
    }
  }, [handlePointerDown, handlePointerMove, handlePointerUp])
  const hdrEquirect = useMemo(() => new THREE.TextureLoader().load(
    "src/empty_warehouse_01_2k.hdr",  
    () => { 
      hdrEquirect.mapping = THREE.EquirectangularReflectionMapping; 
    }
  ), []);
  const material = new THREE.MeshPhysicalMaterial({  
    roughness: 0.1,
    transmission: 1,
    thickness: 2,
    transmissionRoughness: 0,
    clearcoat: 1,
    envMap: hdrEquirect,
  });

  return (
    <group ref={group} {...props} dispose={null} position={[0, -1, 0]}>
      <group name="Scene">
        <group ref={orbit} name="Orbit" position={[-0.065, 1.323, -0.062]}   rotation={[0, 0.001, 0.02]} scale={0.683}>
          {/* scale should be in relashition to how close far from the cameram the mesh is */}
          <mesh name="Planet_0" geometry={new THREE.IcosahedronGeometry(1, 8)} material={material}   position={[0.947, 0.535, -1.034]} scale={0.2 } >
  
          </mesh>
          <mesh name="Planet-1"  geometry={new THREE.IcosahedronGeometry(1, 8)} material={material} position={[0.947, 0.535, 1.034]} scale={0.192} />
          <mesh name="Planet-2"  geometry={new THREE.IcosahedronGeometry(1, 8)} material={material} position={[-1.034, 0.535, 0.947]} scale={0.192} />
          <mesh name="Planet-3"  geometry={new THREE.IcosahedronGeometry(1, 8)} material={material} position={[-1.034, -0.535, -0.947]} scale={0.192} />
          <mesh name="Planet-4"  geometry={new THREE.IcosahedronGeometry(1, 8)} material={material} position={[-1.034, -0.535, 0.947]} scale={0.192} />
        </group>
        <group name="Avatar">
          <primitive object={nodes.Hips} />
          <group name="body">
            <skinnedMesh name="avaturn_shoes_0" geometry={nodes.avaturn_shoes_0.geometry} material={materials.avaturn_shoes_0_material} skeleton={nodes.avaturn_shoes_0.skeleton} />
            <skinnedMesh name="avaturn_shoes_0_1" geometry={nodes.avaturn_shoes_0_1.geometry} material={materials.avaturn_body_material} skeleton={nodes.avaturn_shoes_0_1.skeleton} />
            <skinnedMesh name="avaturn_shoes_0_2" geometry={nodes.avaturn_shoes_0_2.geometry} material={materials.avaturn_glasses_0_material} skeleton={nodes.avaturn_shoes_0_2.skeleton} />
            <skinnedMesh name="avaturn_shoes_0_3" geometry={nodes.avaturn_shoes_0_3.geometry} material={materials.avaturn_glasses_1_material} skeleton={nodes.avaturn_shoes_0_3.skeleton} />
            <skinnedMesh name="avaturn_shoes_0_4" geometry={nodes.avaturn_shoes_0_4.geometry} material={materials.avaturn_look_0_material} skeleton={nodes.avaturn_shoes_0_4.skeleton} />
          </group>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/models/Avatar.glb')